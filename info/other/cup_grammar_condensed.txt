start with Program;
Program ::= DeclarationList:decList{:   RESULT = new Program(0, 0, (DecList)decList);:};
DeclarationList ::= DeclarationList:dl Declaration:d{:   RESULT = new DecList((Dec)d, (DecList)dl);:}| Declaration:d{:   RESULT = new DecList((Dec)d, null);:};
Declaration ::= VarDeclaration:varDec{:  RESULT = varDec;:}| FunDeclaration:funDec{:  RESULT = funDec;:}| FunPrototype:funProto{:    RESULT = funProto;:};
VarDeclaration ::= TypeSpecifier:type ID:id SEMI{:    RESULT = new SimpleDec(typeleft, typeright, (NameTy)type, id);:}| TypeSpecifier:type ID:id LBRACKET NUM:num RBRACKET SEMI{:    RESULT = new ArrayDec(((NameTy)type).row, ((NameTy)type).col, (NameTy)type, id, ((Integer)num).intValue()); // Correctly use row and col from type and cast num to Integer:};
TypeSpecifier ::= BOOLEAN:b{:  RESULT = new NameTy(bleft, bright, NameTy.BOOL);:}| INT:i{:  RESULT = new NameTy(ileft, iright, NameTy.INT);:}| VOID:v{:  RESULT = new NameTy(vleft, vright, NameTy.VOID);:};
FunDeclaration ::= TypeSpecifier:type ID:id LPAREN Params:params RPAREN CompoundStmt:body{:  RESULT = new FunDec(((NameTy)type).row, ((NameTy)type).col, (NameTy)type, id, (VarDecList)params, (CompoundExp)body);:};
FunPrototype ::= TypeSpecifier:type ID:id LPAREN Params:params RPAREN SEMI{:    RESULT = new FunDec(((NameTy)type).row, ((NameTy)type).col, (NameTy)type, id, (VarDecList)params, new NilExp(0, 0));:};
Params ::= ParamList:paramList{:  RESULT = paramList;:}|{:  RESULT = new VarDecList(null, null);:}| VOID{:  RESULT = new VarDecList(null, null);:};
ParamList ::= ParamList:paramList COMMA Param:param{:  RESULT = new VarDecList((VarDec)param, (VarDecList)paramList);:}| Param:param{:  RESULT = new VarDecList((VarDec)param, null);:};
Param ::= TypeSpecifier:type ID:id{:    RESULT = new SimpleDec(((NameTy)type).row, ((NameTy)type).col, (NameTy)type, id);:}| TypeSpecifier:type ID:id LBRACKET RBRACKET{:    RESULT = new ArrayDec(((NameTy)type).row, ((NameTy)type).col, (NameTy)type, id, -1);:};
CompoundStmt ::= LBRACE LocalDeclarations:localDecs StatementList:stmtList RBRACE{:    VarDecList varDecList = (VarDecList)localDecs;    if (varDecList == null) { // Handle case: no local declarations//pSystem.out.println("varDecList == null.");        varDecList = new VarDecList(null, null);    }    ExpList expList = (ExpList) stmtList;    if (expList == null) { // Handle case: no statements. initialize with NilExp for an 'empty' statement list//pSystem.out.println("expList == null.");        expList = new ExpList(new NilExp(-1, -1), null);    }    RESULT = new CompoundExp(0, 0, varDecList, expList);:};
LocalDeclarations ::= LocalDeclarations:localDecs VarDeclaration:varDec{:    if (!(varDec instanceof ErrorDec)) {        RESULT = new VarDecList((VarDec)varDec, (VarDecList)localDecs);    } else {        RESULT = localDecs; // Skip this declaration.    }:}|{:    RESULT = null; // Indicating no declarations.:};
StatementList ::= {:    RESULT = null;//new ExpList(new NilExp(0, 0), null); :}| StatementList:stmtList Statement:stmt{:    RESULT = new ExpList((Exp)stmt, (ExpList)stmtList); :};
Statement ::= ExpressionStmt:exprStmt{:RESULT = exprStmt;:}| CompoundStmt:compStmt{:RESULT = compStmt;:}| SelectionStmt:selStmt{:RESULT = selStmt;:}| IterationStmt:iterStmt{:RESULT = iterStmt;:}| ReturnStmt:retStmt{:RESULT = retStmt;:};
ExpressionStmt ::= Expression:exp SEMI{:    RESULT = (Exp)exp; :}| SEMI{:    RESULT = new NilExp(0, 0); :};
SelectionStmt ::= IF LPAREN Expression:exp RPAREN Statement:thenStmt{:    RESULT = new IfExp(((Exp)exp).row, ((Exp)exp).col, (Exp)exp, (Exp)thenStmt, new NilExp(0, 0));:}| IF LPAREN Expression:exp RPAREN Statement:thenStmt ELSE Statement:elseStmt{:    RESULT = new IfExp(((Exp)exp).row, ((Exp)exp).col, (Exp)exp, (Exp)thenStmt, (Exp)elseStmt);:};
IterationStmt ::= WHILE LPAREN Expression:exp RPAREN Statement:stmt{:    RESULT = new WhileExp(((Exp)exp).row, ((Exp)exp).col, (Exp)exp, (Exp)stmt);:}| WHILE:w LPAREN RPAREN:rp Statement:stmt{:    RESULT = new WhileExp(wleft, wleft, new NilExp(rpleft, rpright), (Exp)stmt);:}| WHILE:w Statement:stmt{:    RESULT = new ErrorDec(wleft, wright, errorMsg);:};
ReturnStmt ::= RETURN:r SEMI{:    RESULT = new ReturnExp(rleft, rright, new NilExp(rleft, rright)); :}| RETURN Expression:exp SEMI{:    RESULT = new ReturnExp(expleft, expright, (Exp)exp); :};
Expression ::= AssignmentExpression:assignExp  {:RESULT = assignExp;  :}  | OboolExpression:boolExp  {:RESULT = boolExp;  :}  ;
AssignmentExpression ::= Var:var ASSIGN:as Expression:exp{:RESULT = new AssignExp(asleft, asright, varExp, (Exp)exp);:};
Var ::= ID:id{:RESULT = new SimpleVar(idleft, idright, id); :}| ID:id LBRACKET Expression:exp RBRACKET{:RESULT = new IndexVar(idleft, idright, id, (Exp)exp); :};
OboolExpression ::= AboolExpression:exp{:RESULT = exp;:}| OboolExpression:left OR:or AboolExpression:right{:RESULT = new OpExp(orleft, orright, (Exp)left, OpExp.OR, (Exp)right); :};
AboolExpression ::= UboolExpression:exp{:RESULT = exp;:}| AboolExpression:left AND UboolExpression:right{:RESULT = new OpExp(0, 0, (Exp)left, OpExp.AND, (Exp)right); :};
UboolExpression ::= SimpleExpression:exp{:RESULT = (Exp)exp;:}| NOT UboolExpression:exp{:RESULT = new OpExp(expleft, expright, new NilExp(0, 0), OpExp.NOT, (Exp)exp);:};
SimpleExpression ::= AdditiveExpression:exp{:RESULT = exp;:}| SimpleExpression:left RelationalOperator:op AdditiveExpression:right{:RESULT = new OpExp(opleft, opright, leftExp, ((Integer)op).intValue(), rightExp);:};
RelationalOperator ::= LT{:RESULT = OpExp.LT;:}| LE{:RESULT = OpExp.LE;:}| GT{:RESULT = OpExp.GT;:}| GE{:RESULT = OpExp.GE;:}| EQ{:RESULT = OpExp.EQ;:}| NE{:RESULT = OpExp.NE;:};
AdditiveExpression ::= Term:term{:RESULT = term;:}| AdditiveExpression:addExp addop:op Term:term{:RESULT = new OpExp(addExpleft, addExpright, (Exp)addExp, ((Integer)op).intValue(), (Exp)term);:};
addop ::= PLUS{:RESULT = OpExp.PLUS; :}| MINUS{:RESULT = OpExp.MINUS; :};
Term ::= Term:term mulop:op SignedFactor:signedFactor{:RESULT = new OpExp(0, 0, termExp, ((Integer)op).intValue(), signedFactorExp);:}| SignedFactor:signedFactor{:RESULT = signedFactor instanceof Var ? new VarExp(0, 0, (Var)signedFactor) : signedFactor;:};
mulop ::= TIMES{:RESULT = OpExp.MUL; :}| DIVIDE{:RESULT = OpExp.DIV; :};
SignedFactor ::= MINUS SignedFactor:signedFactor{:RESULT = new OpExp(0, 0, new NilExp(0, 0), OpExp.UMINUS, (Exp)signedFactor);:}| Factor:factor{:RESULT = factor;:};
Factor ::= LPAREN Expression:exp RPAREN{:RESULT = exp;:}| Var:var{:RESULT = var;:}| Call:call{:RESULT = call;:}| NUM:num{:RESULT = new IntExp(numleft, numright, ((Integer)num).intValue());:}| TRUTH:truth{:RESULT = new BoolExp(truthleft, truthright, truth);:};
Call ::= ID:id LPAREN Args:args RPAREN{:RESULT = new CallExp(idleft, idright, id, (ExpList)args);:}| ID:id LPAREN RPAREN{:RESULT = new CallExp(idleft, idright, id, null);:};
Args ::= ArgList:argList{:RESULT = argList; :};
ArgList ::= ArgList:argList COMMA Expression:exp{:RESULT = new ExpList((Exp)exp, (ExpList)argList);:}| Expression:exp{:RESULT = new ExpList((Exp)exp, null);:};
