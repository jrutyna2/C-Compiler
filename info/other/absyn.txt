=== Absyn.java ===
package absyn;
abstract public class Absyn {
    public int row, col;
    public Absyn(int row, int col) {
            this.row = row;
            this.col = col;
    }
    abstract public void accept( AbsynVisitor visitor, int level );
}
=== AbsynVisitor.java ===
package absyn;
public interface AbsynVisitor {
    // Abstract Syntax Tree classes visit methods
    public void visit(ErrorDec errorDec, int level);
    public void visit(Program program, int level);
    public void visit(DecList decList, int level);
    public void visit(SimpleDec simpleDec, int level);
    public void visit(ArrayDec arrayDec, int level);
    public void visit(NameTy nameTy, int level);
    public void visit(FunDec funDec, int level);
    public void visit(NilExp nilExp, int level);
    public void visit(VarDecList varDecList, int level);
    public void visit(ExpList expList, int level);
    public void visit(CompoundExp compoundExp, int level);
    public void visit(IfExp ifExp, int level);
    public void visit(WhileExp whileExp, int level);
    public void visit(ReturnExp returnExp, int level);
    public void visit(VarExp varExp, int level);
    public void visit(AssignExp assignExp, int level);
    public void visit(SimpleVar simpleVar, int level);
    public void visit(IndexVar indexVar, int level);
    public void visit(OpExp opExp, int level);
    public void visit(IntExp intExp, int level);
    public void visit(BoolExp boolExp, int level);
    public void visit(CallExp callExp, int level);
}
=== ArrayDec.java ===
package absyn;
public class ArrayDec extends VarDec {
    public int size; // The size of the array
    public ArrayDec(int row, int col, NameTy typ, String name, int size) {
        super(row, col, typ, name);
        this.size = size;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    // Method to get the size of the array
    public int getSize() {
        return size;
    }
    // Method to represent the ArrayDec node as a String
    @Override
    public String toString() {
        return "ArrayDec: " + name + ", type: " + typ.toString() + "[" + size + "]";
    }
}
=== AssignExp.java ===
package absyn;
public class AssignExp extends Exp {
    public VarExp lhs;
    public Exp rhs;
    public AssignExp(int row, int col, VarExp lhs, Exp rhs) {
        super(row, col);
        this.lhs = lhs;
        this.rhs = rhs;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        // This assumes that VarExp and Exp both have a functioning toString method.
        return lhs.toString() + " = " + rhs.toString();
    }
}
=== BoolExp.java ===
package absyn;
public class BoolExp extends Exp {
    public boolean value;
    public BoolExp(int row, int col, boolean value) {
        super(row, col);
        this.value = value;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        return String.valueOf(value);
    }
}
=== CallExp.java ===
package absyn;
public class CallExp extends Exp {
    public String func; // The name of the function being called
    public ExpList args; // The list of arguments passed to the function
    public CallExp(int row, int col, String func, ExpList args) {
        super(row, col);
        this.func = func;
        this.args = args;
    }
    public String getName() {
        return(func);
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(func).append("("); // Append function name and opening parenthesis
        // Append a string representation of each argument, separated by commas
        ExpList current = args;
        while (current != null && current.head != null) {
            sb.append(current.head.toString()); // Use toString of the head (which is an Exp)
            current = current.tail;
            if (current != null && current.head != null) {
                sb.append(", "); // Separate arguments with a comma
            }
        }
        sb.append(")"); // Append closing parenthesis
        return sb.toString();
    }
}
=== CompoundExp.java ===
package absyn;
public class CompoundExp extends Exp {
    public VarDecList localDecs;
    public ExpList stmtList;
    public CompoundExp(int row, int col, VarDecList localDecs, ExpList stmtList) {
        super(row, col);
        this.localDecs = localDecs;
        this.stmtList = stmtList;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        return "LocalDeclarations: " + localDecs.toString() + "StatementList: " + stmtList.toString();
    }
}
=== Dec.java ===
package absyn;
public abstract class Dec extends Absyn {
    public Dec(int row, int col) {
        super(row, col);
    }
    // Abstract toString method to be implemented by subclasses
    @Override
    public abstract String toString();
}
=== DecList.java ===
package absyn;
public class DecList extends Absyn {
    public Dec head;
    public DecList tail;
    public DecList(Dec head, DecList tail) {
        super(0, 0); // Placeholder values for row and col
        this.head = head;
        this.tail = tail;
    }
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        DecList current = this;
        while (current != null && current.head != null) {
            sb.append(current.head.toString());
            if (current.tail != null) {
                sb.append(", ");
            }
            current = current.tail;
        }
        return "DecList: [" + sb.toString() + "]";
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
}
=== ErrorDec.java ===
package absyn;
public class ErrorDec extends Dec {
    public String errorMessage;
    public ErrorDec(int row, int col, String errorMessage) {
        super(row, col); // Assuming a constructor similar to other Dec subclasses
        // this.row = row;
        // this.col = col;
        this.errorMessage = errorMessage;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        return "Error at row " + row + ", col " + col + ": " + errorMessage;
    }
}
=== Exp.java ===
package absyn;
public abstract class Exp extends Absyn {
    public Dec dtype;
    public Exp(int row, int col) {
        super(row, col);
        this.dtype = null;
    }
    public Dec getType() {
        return dtype;
    }
    public void setType(Dec dtype) {
        this.dtype = dtype;
    }
    public boolean isBoolean() {
        return this instanceof BoolExp;
    }
    @Override
    public abstract String toString();
}
=== ExpList.java ===
package absyn;
public class ExpList extends Absyn {
    public Exp head;
    public ExpList tail;
    public ExpList(Exp head, ExpList tail) {
        super(-1, -1);
        this.head = head;
        this.tail = tail;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        // Start with the head of the list
        String result = (head == null) ? "" : head.toString();
        // If there's more in the list, handle it recursively
        if (tail != null) {
            result += ", " + tail.toString(); // Use a comma to separate expressions
        }
        return result;
    }
}
=== FunDec.java ===
package absyn;
public class FunDec extends Dec {
    public NameTy result; // The return type of the function
    public String funcName; // The name of the function
    public VarDecList params; // List of parameters
    public Exp body; // The body of the function
    public FunDec(int row, int col, NameTy result, String funcName, VarDecList params, Exp body) {
        super(row, col);
        this.result = result;
        this.funcName = funcName;
        this.params = params;
        this.body = body;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Function: ").append(funcName);
        sb.append(", Return type: ").append(result);
        if (params != null) {
            sb.append(", Parameters: [").append(params.toString()).append("]");
        } else {
            sb.append(", Parameters: []");
        }
        if (body != null) {
            sb.append(", Body: ").append(body.toString());
        } else {
            sb.append(", Body: {}");
        }
        return sb.toString();
    }
}
=== IfExp.java ===
package absyn;
public class IfExp extends Exp {
    public Exp test;
    public Exp thenClause;
    public Exp elseClause; // This can be null if there is no else clause
    public IfExp(int row, int col, Exp test, Exp thenClause, Exp elseClause) {
        super(row, col);
        this.test = test;
        this.thenClause = thenClause;
        this.elseClause = elseClause;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        String result = "if (" + test.toString() + ") " + thenClause.toString();
        if (elseClause != null) {
            result += " else " + elseClause.toString();
        }
        return result;
    }
}
=== IndexVar.java ===
package absyn;
public class IndexVar extends Var {
    public Exp index;
    public IndexVar(int row, int col, String name, Exp index) {
        super(row, col, name); // Pass name to the superclass constructor
        this.index = index;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    // Implementation of the abstract toString method
    @Override
    public String toString() {
        // Return var's type and name as string rep
        return "IndexVar: " + name + "[" + (index == null ? "" : index.toString()) + "]"; // Handle null index expression if necessary
    }
}
=== IntExp.java ===
package absyn;
public class IntExp extends Exp {
    public int value;
    public IntExp(int row, int col, int value) {
        super(row, col);
        this.value = value;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        return Integer.toString(value);
    }
}
=== NameTy.java ===
package absyn;
public class NameTy extends Absyn {
    // Define type constants
    public final static int BOOL = 0;
    public final static int INT = 1;
    public final static int VOID = 2;
    public int typ; // The type of the variable/function return, using the constants above
    public NameTy(int row, int col, int typ) {
        super(row, col);
        this.typ = typ;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        switch (typ) {
            case BOOL:
                return "BOOL";
            case INT:
                return "INT";
            case VOID:
                return "VOID";
            default:
                return "UNKNOWN";
        }
    }
}
=== NilExp.java ===
package absyn;
public class NilExp extends Exp {
    public NilExp(int row, int col) {
        super(row, col);
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        return "NilExp";
    }
}
=== OpExp.java ===
package absyn;
public class OpExp extends Exp {
    // Define operator constants
    public final static int PLUS = 0;
    public final static int MINUS = 1;
    public final static int UMINUS = 2; // Unary minus
    public final static int MUL = 3;
    public final static int DIV = 4;
    public final static int EQ = 5; // Equal
    public final static int NE = 6; // Not equal
    public final static int LT = 7; // Less than
    public final static int LE = 8; // Less than or equal to
    public final static int GT = 9; // Greater than
    public final static int GE = 10; // Greater than or equal to
    public final static int NOT = 11;
    public final static int AND = 12;
    public final static int OR = 13;
    public Exp left;
    public int op; // The operation, using the constants defined above
    public Exp right; // Right-hand side of the operation; can be null for unary ops
    public OpExp(int row, int col, Exp left, int op, Exp right) {
        super(row, col);
        this.left = left;
        this.op = op;
        this.right = right;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        String opStr = switch (op) {
            case PLUS -> "+";
            case MINUS -> "-";
            case UMINUS -> "-";
            case MUL -> "*";
            case DIV -> "/";
            case EQ -> "==";
            case NE -> "!=";
            case LT -> "<";
            case LE -> "<=";
            case GT -> ">";
            case GE -> ">=";
            case NOT -> "!";
            case AND -> "&&";
            case OR -> "||";
            default -> "unknown_op";
        };
        return "(" + left.toString() + " " + opStr + " " + right.toString() + ")";
    }
}
=== Program.java ===
package absyn;
public class Program extends Absyn {
    public DecList declarations;
    public Program(int row, int col, DecList declarations) {
        super(row, col);
        this.declarations = declarations;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        // Start with the basic program structure
        StringBuilder sb = new StringBuilder("Program:\n");
        // Check if there are declarations to print
        if (declarations != null) {
            sb.append(declarations.toString()); // Append the string representation of the declarations list
        } else {
            sb.append(" No Declarations");
        }
        return sb.toString();
    }
}
=== ReturnExp.java ===
package absyn;
public class ReturnExp extends Exp {
    public Exp exp; // This can be null if the function returns void
    public ReturnExp(int row, int col, Exp exp) {
        super(row, col);
        this.exp = exp;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        if (exp == null) {
            return "return;";
        } else {
            return "return " + exp.toString() + ";";
        }
    }
}
=== SimpleDec.java ===
package absyn;
public class SimpleDec extends VarDec {
    public SimpleDec(int row, int col, NameTy typ, String name) {
        super(row, col, typ, name);
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        // Call super.typ.toString() to use the NameTy's toString method
        return "SimpleDec: " + name + ", type: " + typ.toString();
    }
}
=== SimpleVar.java ===
package absyn;
public class SimpleVar extends Var {
    public SimpleVar(int row, int col, String name) {
        super(row, col, name);
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        return "SimpleVar: " + name; // Return var's type and name as string rep
    }
}
=== Var.java ===
package absyn;
abstract public class Var extends Absyn {
    public String name; // Consider using protected if subclasses need direct access
    public Var(int row, int col, String name) {
        super(row, col);
        this.name = name;
    }
    // Getter for the variable's name
    public String getName() {
        return name;
    }
    @Override
    public abstract String toString();
}
=== VarDec.java ===
package absyn;
abstract public class VarDec extends Dec {
    public NameTy typ;
    public String name;
    public VarDec(int row, int col, NameTy typ, String name) {
        super(row, col);
        this.typ = typ;
        this.name = name;
    }
    // Getter for the type
    public NameTy getType() {
        return typ;
    }
    // Getter for the name
    public String getName() {
        return name;
    }
}
=== VarDecList.java ===
package absyn;
public class VarDecList extends Absyn {
    public VarDec head;
    public VarDecList tail;
    public VarDecList(VarDec head, VarDecList tail) {
        super(-1, -1); // Placeholder values for row and col
        this.head = head;
        this.tail = tail;
    }
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        VarDecList current = this;
        while (current != null) {
            if (current.head != null) {
                sb.append(current.head.toString());
                if (current.tail != null) {
                    sb.append(", ");
                }
            }
            current = current.tail;
        }
        return "VarDecList: [" + sb.toString() + "]";
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
}
=== VarExp.java ===
package absyn;
public class VarExp extends Exp {
    public Var variable;
    public VarExp(int row, int col, Var variable) {
        super(row, col);
        this.variable = variable;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        return variable.toString(); // Delegate to Var's toString method
    }
}
=== WhileExp.java ===
package absyn;
public class WhileExp extends Exp {
    public Exp test;
    public Exp body;
    public WhileExp(int row, int col, Exp test, Exp body) {
        super(row, col);
        this.test = test;
        this.body = body;
    }
    @Override
    public void accept(AbsynVisitor visitor, int level) {
        visitor.visit(this, level);
    }
    @Override
    public String toString() {
        return "while (" + test.toString() + ") " + body.toString();
    }
}
