TM Simulator

 CIS*4650 (Winter 2024)
Incremental Steps for C3
§ Subtask 1: Get familiar with TM Simulator architecture and its
  assembly code and test the TM Simulator package.




                                                                   2
Basic Architecture
#define   IADDR_SIZE 1024
#define   DADDR_SIZE 1024
                                               Runtime Errors:
#define   NO_REGS 8
#define   PC_REG 7                              - IMEM_ERR:
                                                  reg[PC_REG] < 0
INSTRUCTION iMem[IADDR_SIZE];                     reg[PC_REG] >= IADDR_SIZE
int dMem[DADDR_SIZE];
int reg[NO_REGS];                               - DMEM_ERR: similar to iMem
                                                  above

                                                - ZERO_DIV:
do {
   /* fetch an instruction */
   currentInstruction = iMem[reg[PC_REG]++];
   /* execute current instruction */
   …
} while( !(halt || error) );
                                                                          3
Register Only (RO) Instructions
Format: opcode r, s, t

Opcode          Effect

HALT            stop execution
IN              reg[r] <- read an integer from input
OUT             reg[r] -> write to standard output

ADD             reg[r]   =   reg[s]   + reg[t]
SUB             reg[r]   =   reg[s]   - reg[t]
MUL             reg[r]   =   reg[s]   * reg[t]
DIV             reg[r]   =   reg[s]   / reg[t]   (may generate ZERO_DIV)


                                                                      4
Register Memory (RM) Instructions
Format: opcode r, d(s)

(a = d + reg[s]; may generate DMEM_ERR if a < 0 or a >= DADDR_SIZE)

Opcode           Effect

LD               reg[r] = dMem[a]
LDA              reg[r] = a
LDC              reg[r] = d
ST               dMem[a] = reg[r]
JLT              if( reg[r] < 0 ) reg[PC_REG] = a
JLE              if( reg[r] <= 0 ) reg[PC_REG] = a
JGT              if( reg[r] > 0 ) reg[PC_REG] = a
JGE              if( reg[r] >= 0 ) reg[PC_REG] = a
JEQ              if( reg[r] == 0 ) reg[PC_REG] = a
JNE              if( reg[r] != 0 ) reg[PC_REG] = a
                                                                      5
     Sample Program
* This program inputs an integer, computes its factorial if it is positive,
* and prints the result

0:      IN 0, 0, 0                r0 = read
1:      JLE 0, 6(7)               if 0 < r0 then
2:      LDC 1, 1, 0                  r1 = 1
3:      LDC 2, 1, 0                  r2 = 1
                                  * repeat
4:      MUL 1, 1, 0                   r1 = r1 * r0
5:      SUB 0, 0, 2                   r0 = r0 - r2
6:      JNE 0, -3(7)                 until r0 == 0
7:      OUT 1, 0, 0                  write r1
8:      HALT 0, 0, 0              halt

* end of program
                                                                              6
Three-Address vs Assembly Code
  read x
  t1 = x > 0               0:      IN 0, 0, 0
  if_false t1 goto L1      1:      JLE 0, 6(7)
  fact = 1                 2:      LDC 1, 1, 0
  label L2                 3:      LDC 2, 1, 0
  t2 = fact * x            4:      MUL 1, 1, 0
  fact = t2                5:      SUB 0, 0, 2
  t3 = x - 1               6:      JNE 0, -3(7)
  x = t3                   7:      OUT 1, 0, 0
  t4 = x == 0              8:      HALT 0, 0, 0
  if_false t4 goto L2
  write fact
  label L1              (Compared with 70 instructions
  halt                  “fac.tm” ???)

                                                     7
Flexible Order for Backpatching
0:   IN 0, 0, 0
2:   LDC 1, 1, 0    skip an instruction
3:   LDC 2, 1, 0
4:   MUL 1, 1, 0
5:   SUB 0, 0, 2
6:   JNE 0, -3(7)
7:   OUT 1, 0, 0
1:   JLE 0, 6(7)    backpatching for a jump
8:   HALT 0, 0, 0




                                              8
           Incremental Steps for C3
§ Subtask 1: Get familiar with TM Simulator architecture and its
  assembly code and test the TM Simulator package.
§ Subtask 2: Refactor the syntax trees and the visitor interface.




                                                                    9
Required Attributes for Syntax Trees
- Declarations:

 ArrayDec: size (Already done in Checkpoint One)

 FunctionDec: funaddr (To be added)

 VarDec:
   offset: location relative to fp (To be added)
   nestLevel: gp or the current fp (To be added)

- References:

 VarExp: dtype to a VarDec (Already done in Checkpoint Two)

 CallExp: dtype to a FunctionDec (Already done in Checkpoint Two)

                                                                    10
     Extending AST’s for Code Generation
                                     ofp                   void main( void ) {       ofp      0
     void foo( int x, int y ) {      ret                     int a; int b;           ret     -1
       …                             x                       foo( a, b );            a       -2
     }                               y                     }                         b       -3


   AST

             funDec(foo)                          funDec(main)
             funaddr = ?                            funaddr=?

                   CompoundExp             null
                     …                                     CompoundExp

SimpleDec(x)         SimpleDec(y)                                                   CallExp(foo)
nestLevel = 1        nestLevel = 1
offset = -2          offset = -3       SimpleDec(a)          SimpleDec(b)
                                       nestLevel = 1         nestLevel = 1
                                       offset = -2           offset = -3         Simple-     Simple-
                                                                                 Var(a)      Var(b)

                                                                                                   11
Implementation Details
    For a FunctionDec, add ”int funaddr” to record the start address of the
corresponding function, which is needed for a function call.

    For a VarDec (either SimpleDec or ArrayDec), we need to add “int
nestLevel” and “int offset”. The former is either 0 for “global” scope or “1”
for “local” scope, and the latter is the offset within the related stackframe
for memory access.

   If “nestLevel = 0” and “offset = -3”, we will go the global frame
pointed by ”gp” and its 4th location to read/write data. If “nestLevel = 1”
and “offset=-2”, we will go the current stackframe pointed by “fp” and
access its third location (right after “ofp”and “return addr”).

    For a Var (either SimpleVar or IndexVar) and a CallExp, we need to add
a link to its related definitions: SimpleDec, ArrayDec, and FunctionDec.
That’s where we can find the memory location or the function address.

                                                                                12
    Visitor Class for Code Generation
public class CodeGenerator implements AbsynVisitor {
   int mainEntry, globalOffset;
   // add constructor and all emitting routines
   …
   public void visit(Absyn trees) { // wrapper for post-order traversal
       // generate the prelude
       …
       // generate the i/o routines
       …
       // make a request to the visit method for DecList
       trees.accept(this, 0, false);
       // generate finale
       …
   }
   // implement all visit methods in AbsynVisitor such as the following
   public void visit(DecList decs, int offset, Boolean isAddress) { …}
   …
}                                                                      13
  Refactor the Visitor Pattern
§ Add “boolean isAddr” to all function headers for the visitor pattern:

In Absyn.java:
   abstract public void accept(AbsynVisitor visitor, int value, boolean flag);

In AbsynVisitor.java:
   public void visit(AssignExp exp, int value, boolean flag);
   …

In ShowTreeVisitor.java and SemanticAnalyzer.java:
   public void visit(AssignExp exp, int level, boolean flag);
   …

In CM.java:
   ShowTreeVisitor visitor = new ShowTreeVisitor();
   result.accept(visitor, 0, false);
   …
                                                                                 14
           Incremental Steps for C3
§ Subtask 1: Get familiar with TM Simulator architecture and its
  assembly code and test the TM Simulator package.
§ Subtask 2: Refactor the syntax trees and the visitor interface.
§ Subtask 3: Implement the basic code structure that contains the
  code for “main” with simple declarations, expressions, and
  assignments only (see Slides 6-7 in the notes on “10-Intermediate
  Code Generation”).




                                                                      15
 Runtime Environments for C-Minus
INSTRUCTION iMem[IADDR_SIZE];          int dMem[DADDR_SIZE];

1023                            1023




 0                               0


                                                           16
     Runtime Environment for C-Minus
                                                         int f( int x, int y ) {
fp             ofp             ofpFO = 0                   int z;
               ret             retFO = -1                  …
               …               initFO = -2               }
               params
                                                                       frameOffset = -5
               …
               …
                                              fp              ofp                   0
               local vars                                     ret                  -1
               …                                              x: int               -2
               …                                              y: int               -3
               temps                                          z: int               -4
               …                                                                   -5




     (Note that “frameOffset” is used for “sp”, which can be passed as a parameter
      in the recursive functions for code generation)
                                                                                        17
 Registers and Relative Addresses
§ Prelude for code generation:
  0: LD gp, 0(ac)         * load gp with maxaddress
  1: LDA fp, 0(gp)        * copy gp to fp
  2: ST ac, 0(ac)         * clear value at location 0

                                                   Special registers:
§ Jump to a different instruction:
                                                   #define   pc    7
   • e.g., from location 42 to location 27:        #define   gp    6
                                                   #define   fp    5
    42: LDA pc, -16(pc)                            #define   ac    0
                                                   #define   ac1   1

                          a = (42 + 1) – 16 = 27
                          offset =27 – (42 + 1) = -16
                                                                        18
        Code for Prelude
§ Accessing global data:
      0: LD gp, 0(ac)           * load gp with maxaddress: reg[gp] = 1023
      1: LDA fp, 0(gp)          * copy gp to fp: reg[fp] = 1023
      2: ST ac, 0(ac)           * clear location 0: dMem[0] = 0

 1023                                      fp, gp   1023




  0            1023                                   0               0
(Initialization of dMem by TM Simulator)     (Initialization of dMem by TM Simulator)   19
 Example Code
int y;

int gcd( int u, int v ) {
  if( v == 0 )
      return u;
  else
      return gcd( v, u – u / v * v );
}

void main( void ) {
  int x;
  x = input();
  y = 10;
  output( gcd(x, y) );
}
                                        20
     Basic Code Structure
Lines:   Tasks to do
                                     - prelude:

0-2:     prelude                     0: LD 6, 0(0) load gp with maxaddr
                                     1: LDA 5, 0(6) copy gp to fp
3:       jump around i/o functions   2: ST 0, 0(0) clear content at loc 0

4-10:    code for i/o functions
                                     - finale:
11:      jump around gcd
                                     81:   ST 5, -1(5)   push ofp
12-48:   code for gcd                82:   LDA 5, -1(5)   push frame
                                     83:   LDA 0, 1(7)   load ac with ret ptr
                                     84:   LDA 7, -35(7) jump to main loc
49:      jump around main
                                     85:   LD 5, 0(5)    pop frame
                                     86:   HALT 0, 0, 0
50-80:   code for main

81-86:   finale
                                                                        21
Code for Finale                           gp, fp       y: 10
                                                                     globalOffset



gp
       y: 10
fp     ofp            -1
       ret


                                  ST 0, -1(5)        store return
                                  * Code inside main
                                  LD 7, -1(5)        return to caller


 ST fp, globalOffset+ofpFO (fp)   81:   ST 5, -1(5)   push ofp
 LDA fp, globalOffset (fp)        82:   LDA 5, -1(5)   push frame
 LDA ac, 1 (pc)                   83:   LDA 0, 1(7)   load ac with ret ptr
 LDA pc, … (pc)                   84:   LDA 7, -35(7) jump to main loc
 LD fp, ofpFO (fp)                85:   LD 5, 0(5)    pop frame
                                  86:   HALT 0, 0, 0
                                                                             22
    Generating Finale
int mainEntry;               /* absolute address for main */
int globalOffset;             /* next available loc after global frame */

…
emitRM( “ST”, fp, globalOffset+ofpFO, fp, “push ofp” );
emitRM( “LDA”, fp, globalOffset, fp, “push frame” );
emitRM( “LDA”, ac, 1, pc, “load ac with ret ptr” );
emitRM_Abs( “LDA”, pc, mainEntry, “jump to main loc” );
emitRM( “LD”, fp, ofpFO, fp, “pop frame” );             gp
emitRO( “HALT”, 0, 0, 0, “” );                                      y: 10
                                                            fp      ofp     -1
                                                                    ret
- Beginning of a function:

 emitRM( “ST”, ac, retFO, fp, “store return” );


                                                                            23
      Code Emitting Routines
                                          void emitRM( char *op,
/* Routines to generate different kinds     int r, int d, int s, char *c ) {
   of assembly instructions                 fprintf( code, “%3d: %5s %d, %d(%d)”,
*/                                             emitLoc, op, r, d, s );
                                            fprintf( code, “\t%s\n”, c );
static int emitLoc = 0;                     ++emitLoc;
static int highEmitLoc = 0;                 if( highEmitLoc < emitLoc )
                                                highEmitLoc = emitLoc;
                                          }
void emitRO( char *op,
  int r, int s, int t, char *c ) {        void emitRM_Abs( char *op,
  fprintf( code, “%3d: %5s %d, %d, %d”,     int r, int a, char *c ) {
     emitLoc, op, r, s, t );                fprintf( code, “%3d: %5s %d, %d(%d) “,
  fprintf( code, “\t%s\n”, c );                emitLoc, op, r, a – (emitLoc + 1), pc );
  ++emitLoc;                                fprintf( code, “\t%s\n”, c );
  if( highEmitLoc < emitLoc )               ++emitLoc;
      highEmitLoc = emitLoc;                if( highEmitLoc < emitLoc )
}                                               highEmitLoc = emitLoc;
                                          }
                                                                                  24
          Three Offsets to Keep Track of
                iMem                                     dMem
                                          gp




emitLoc                                   fp       ofp                  globalOffset
                                                   ret
                                                   …
            Code generated                                              frameOffset



            (Initialized to 0)                   (Initialized to max)


      - Main function is the last declaration in a program: that’s where we set
        values for “entry” and “globalOffset”.

                                                                                  25
   Code Emitting Routines
/* Routines to maintain the code space */

int emitSkip( int distance ) {
  int i = emitLoc;
  emitLoc += distance;
  if( highEmitLoc < emitLoc )
      highEmitLoc = emitLoc;                /* Routine to generate one line
  return i;                                    of comment
}                                           */

void emitBackup( int loc ) {                void emitComment( char *c ) {
  if( loc > highEmitLoc )                     fprintf( code, “* %s\n”, c );
      emitComment( “BUG in emitBackup” );   }
  emitLoc = loc;
}

void emitRestore( void ) {
  emitLoc = highEmitLoc;
}
                                                                              26
   Backpatching Example
* Standard prelude
0: LD 6, 0(0)
1: LDA 5, 0(6)                          /* code for backpatching */
2: ST 0, 0(0)                           …
* Jump around i/o routines              int savedLoc = emitSkip(1);
* Code for input routine                /*
4: ST 0, -1(5)       store return          code for the i/o routines
                                        */
5: IN 0, 0, 0       input
                                        int savedLoc2 = emitSkip(0);
6: LD 7, -1(5)      return to caller    emitBackup( savedLoc );
* Code for output routine               emitRM_Abs( “LDA”, pc, savedLoc2, “” );
7: ST 0, -1(5)      store return        emitRestore();
8: LD 0, -2(5)       load output value …
9: OUT 0, 0, 0      output
10: LD 7, -1(5)     return to caller
3: LDA 7, 7(7)      jump around i/o code
11:
                                                                              27
 Implementation Details
(1) For the very initial implementation, we can use an empty main function
such as “void main(void) {}”. This should lead to the following sequence of
instructions:

  /* code for prelude */
  …
  /* code for i/o routines */
  …
  12: ST 0, -1(5)       save return address
  13: LD 7, -1(5)       return back to the caller
  11: LDA 7, 2(7)       jump forward to finale
   /* code for finale */
   …

- After that, we can gradually add code generation functions for
expressions, assignments, control structures, functions and recursions,
nested blocks, arrays, and runtime error checking, as suggested in the
marking scheme for Checkpoint Three.
                                                                              28
 Implementation Details
(2) Implement all the emit routines in CodeGenerator.java:

   - Note that every time we emit an instruction, “emitLoc” is always
incremented, and if it exceeds “highEmitLoc”, the latter is also adjusted up.

  - When generating an instruction, avoid using ”fprintf” directly, but use
the related “emit” routine since we can increment “emitLoc” and
“highEmitLoc” as well.

      void emitRO( char *op,
        int r, int s, int t, char *c ) {
        fprintf( code, “%3d: %5s %d, %d, %d”,
           emitLoc, op, r, s, t );
        fprintf( code, “\t%s\n”, c );
        ++emitLoc;
        if( highEmitLoc < emitLoc )
            highEmitLoc = emitLoc;
      }
                                                                                29
 Implementation Details
(3) Maintain three different offsets during code generation:

   - For iMem, declare “emitLoc” and “highEmitLoc” as global variables.
The former points to the current instruction we are generating (may go
back to an earlier location for backpatching), while the latter always points
to the next available space so that we can continue adding new
instructions.

  - The global stackframe at the top of dMem is pointed by the “gp”
register, and its bottom is indicated by the global variable “globalOffset”. If
we have ”int a” and “int b” declared in the global scope, we will have
“globalOffset=-2”. If we have “int x[10]” declared in the global scope, we
will have “globalOffset=-10”.

  - The current stackframe in dMem is pointed by the “fp” register, and its
bottom is indicated by a parameter “frameOffset”, which is local in your
recursive function for code generation. Since the first two locations are
reserved for “ofp” and “return addr”, the parameters and local variables will
start from “-2” location in the stackframe.                                   30
 Implementation Details
(4) Slides 6-7 in the notes on “10-CodeGeneration” show the key steps for
generating intermediate code for expressions. For Checkpoint Three,
however, we need to map them further to generate TM assembly code.
This can be illustrated with the following example:

- Assuming the syntax tree for the expression
                                                         fp
  “x = x + 3” and the stack frame on the right.               ofp           0
- The initial call is “visit(tree, -3, false)” where          ret-addr      -1
   “tree” is an AssignExp and “-3” is the frameOffset.        x:            -2
- Inside the “visit” for AssignExp, we will call
  ”visit(tree.lhs, -4, true)” and “visit(tree.rhs, -5,                      -3
  false) first in the post-order traversal. The former        &x            -4
  is for a SimpleVar and the latter is for an OpExp.
                                                                            -5
- Inside the “visit” for SimpleVar when used as the
  left-hand side of AssignExp, we will compute the                          -6
  address of ”x” and save it in location “-4”. This is                      -7
  done with these two instructions (assuming that
  we are starting with instruction 13):
                                                                                 31
      13: LDA 0, -2(5) and        14: ST 0, -4(5)
   Implementation Details
- Inside the “visit” for OpExp, we will call “visit(tree.left, -6, false)” and
  “visit(tree.right, -7, false)” in the post-order traversal. The former is
  for a SimpleVar and the latter is for an IntExp.
- Inside the “visit” for SimpleVar when not used as the left-hand side
  of AssignExp, we simply save the value of “x” to location “-6” with
  the following two instructions:
                                                        fp    ofp                        0
     15: LD 0, -2(5) and       16: ST 0, -6(5)
- Inside the “visit” for IntExp, we will save the value       ret-addr               -1
   of “3” to location “-7” with these instructions:               x:result of x+3    -2
      17: LDC 0, 3(0) and 18: ST 0, -7(5)
                                                                  result of x + 3    -3
- Back to the “visit” for OpExp, we will do the addition
  save the result in location “-5” with these instructions:       &x                 -4
     19: LD 0, -6(5)     and 20: LD 1, -7(5)                      result of x+3      -5
     21: ADD 0, 0, 1 and 22: ST 0, -5(5)
                                                             value of x              -6
- Back to the “visit” for AssignExp, we will do the
  assignment and save the result to location ”-3” with       value of 3              -7
  the following instructions:
     23: LD 0, -4(5)     and 24: LD 1, -5(5)      and 25: ST 1, 0(0)                32
     26: ST 1, -3(5)
 Implementation Details
- Note that in the above illustration, we need to handle the “visit” for
  SimpleVar differently depending on whether we are computing the left-
  hand side of AssignExp or not. This is distinguished by “isAddr”
  parameter in the “visit(Absyn tree, int offset, boolean isAddr)”.
- The value for “isAddr” is false for most cases except when calling
  “visit(tree.lhs, offset, true)” of AssignExp, since this is when we need to
  compute and save the address of a variable into a memory location.
- For the case of IndexVar, we naturally compute the address of an
  indexed variable, and that value can be saved directly into a memory
  location when used in the left-hand side of AssignExp.
- As a general principle, we use the given location to save the result of an
  OpExp, and the next two locations for its left and right children. In
  addition, register “0” is used heavily for the result, which needs to be
  saved to a memory location as soon as possible.


                                                                                33
           Incremental Steps for C3
§ Subtask 1: Get familiar with TM Simulator architecture and its
  assembly code and test the TM Simulator package.
§ Subtask 2: Refactor the syntax trees and the visitor interface.
§ Subtask 3: Implement the basic code structure that contains the
  code for “main” with simple declarations, expressions, and
  assignments only (see Slides 6-7 in the notes on “10-Intermediate
  Code Generation”).
§ Subtask 4: Implement the code generation for control structures
  (see Slides 15-21 in the notes on ”10-Intermediate Code
  Generation): able to test “fac.cm” and “booltest.cm”.
§ Subtask 5: Implement the calling sequence fully: able to call
  input/output functions and test “gcd.cm” and “mutual.cm”.




                                                                      34
                                                             fp

      Calling Sequence
                                                                                 old
     § Call sequence:                                         fp        ofp      frameOffset
                                                                        ret
                                                                        u: int   initFO(-2)
pc     <code to compute first arg>
                                                                        v: int
       ST ac, frameOffset+initFO (fp)
       <code to compute second arg>
                                                                                 new
       ST ac, frameOffset+initFO-1 (fp)                                          frameOffset
       ST fp, frameOffset+ofpFO (fp)      *   store current fp
       LDA fp, frameOffset (fp)           *   push new frame
       LDA ac, 1 (pc)                     *   save return in ac
       LDA pc, … (pc)                     *   relative jump to function entry
       LD fp, ofpFO (fp)                  *   pop current frame


     § Return sequence:
        ST ac, retFO (fp)             * store return address
        …
        LD pc, retFO (fp)             * return to caller

                                                                                     35
Calling Sequence
     caller
                   callee

                            B


 A

 D



                            C


                                36
     Calling Sequence vs Finale
- calling sequence:

<code to compute first arg>
ST ac, frameOffset+initFO (fp)
<code to compute second arg>       - finale:
ST ac, frameOffset+initFO-1 (fp)
ST fp, frameOffset+ofpFO (fp)      ST fp, globalOffset+ofpFO (fp) push ofp
LDA fp, frameOffset (fp)           LDA fp, globalOffset (fp)      push frame
LDA ac, 1 (pc)                     LDA ac, 1(pc)                  load ac with ret
LDA pc, … (pc)                     LDA pc, … (pc)                 jump to main
LD fp, ofpFO (fp)                  LD fp, ofpFO (fp)              pop frame
                                   HALT 0, 0, 0




                                                                              37
    Incremental Steps for C3
§   Subtask 1: Get familiar with TM Simulator architecture and its
  assembly code and test the TM Simulator package.
§ Subtask 2: Refactor the syntax trees and the visitor interface.
§   Subtask 3: Implement the basic code structure that contains the code for
    “main” with simple declarations, expressions, and assignments only (see
    Slides 6-7 in “10-Intermediate Code Generation”).
§   Subtask 4: Implement the code generation for control structures (see
    Slides 15-21 in”10-Intermediate Code Generation): able to test “fac.cm”.
§   Subtask 5: Implement the calling sequence fully: able to call input/output
    functions and test “gcd.cm”.
§   Subtask 6: Implement the code generation for inner blocks and array
    references: able to test ”sort.cm” (see Slides 8-12 in “10-Intermediate
    Code Generation”)
§   Subtask 7: Implement runtime error checking of the array index: index
    out of bound either below or above the given range
                                                                                 38
 Implementation Detials
- Since an array is a static linear structure
                                                          a[9]:
  with a fixed size, we can store the “size”
  value right below the base address of the                .
  array                                                    .
                                                           .
- When passing an array as an argument,
  the corresponding parameter will be given               a[0]:           a’s base
  the base address of the array in the caller’s           size: 10        address
  stack frame, and right below the base
  address, we can access the “size” value
- Every time we access an indexed variable, we should always check the
  index value: if it is less than 0, we have a runtime error of “out of range
  below”, and if it is greater or equal to “size”, we have a runtime error of
  “out of arrange above”
- Since C- language only has integer values, we can show very large
  negative values such as “-1000000” for “out of range below” and
   “-2000000” for ”out of range above” errors.
                                                                                     39
